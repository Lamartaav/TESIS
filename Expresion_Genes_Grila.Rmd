---
title: "Expresión de Genes"
output: 
  html_document:
    toc: true        # <- Esto activa la tabla de contenido
    toc_depth: 3     # <- Nivel de títulos que se mostrarán (opcional)
    toc_float: false  # <- Hace que el índice flote (opcional)
date: "Índice"
---

```{r setup, include=FALSE}
options(repos = c(CRAN = "https://cloud.r-project.org"))
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)

# Paquete mínimo
if (!requireNamespace("ggplot2", quietly = TRUE)) install.packages("ggplot2")
library(ggplot2)

# --- Cargar datos (local o GitHub) ---
path_local <- "genes_subset_sin_dup.tsv"
if (file.exists(path_local)) {
  df <- read.delim(path_local, sep = "\t", check.names = FALSE, stringsAsFactors = FALSE)
} else {
  df <- read.delim(
    "https://raw.githubusercontent.com/Lamartaav/TESIS/refs/heads/main/genes_subset_sin_dup.tsv",
    sep = "\t", check.names = FALSE, stringsAsFactors = FALSE
  )
}

# Tomar solo columnas tumorales 01A (si no hay, usar todas)
meta_cols   <- c("gene-id","gene-name","gene-type")
sample_cols <- setdiff(colnames(df), meta_cols)
tumor_cols  <- sample_cols[grepl("-01A-", sample_cols)]
if (length(tumor_cols) == 0) tumor_cols <- sample_cols

# Mapa de genes y sinónimos
gene_map <- list(
  "SLC2A1" = c("SLC2A1","GLUT1"),
  "CA9"    = c("CA9","CAIX"),
  "HIF1A"  = c("HIF1A"),
  "EPAS1"  = c("EPAS1","HIF2A"),
  "LDHA"   = c("LDHA"),
  "SLC16A1"= c("SLC16A1","MCT1"),
  "SLC16A3"= c("SLC16A3","MCT4"),
  "HK2"    = c("HK2","HEXOKINASA","HEXOKINASE"),
  "PKM"    = c("PKM"), 
  "GPI"    = c("GPI","PHOSPHOGLUCOSE ISOMERASE","PHOSPHOGLUCO ISOMERASA","PHOSPHOGLUCOISOMERASE"),
  "ALDOA"  = c("ALDOA","ALDOLASA","ALDOLASE A"),
  "PGK1"   = c("PGK1","PHOSPHOGLYCERATE KINASE 1"),
  "PGM1"   = c("PGM1","PHOSPHOGLUCOMUTASE 1"),
  "ENO1"   = c("ENO1","ENOLASE 1"),
  "CD274"  = c("CD274","PDL1","PD-L1"),
  "CD80"   = c("CD80"),
  "CD80"   = c("CD86"),
  "HLA-DRA"= c("HLA-DRA"),
  "IL12B"  = c("IL12B"),
    "NOS2"   = c("NOS2"),
    "TNF"   = c("TNF"),
    "IL1B"   = c("IL1B"),
    "CXCL9"   = c("CXCL9"),
    "CXCL10"   = c("CXCL10"),
  "CD163"  = c("CD163"),
  "MRC1"   = c("MRC1"),
  "IL10"   = c("IL10"),
  "TGFB1"  = c("TGFB1"),
  "MMP9"   = c("MMP9"),
  "VEGFA"  = c("VEGFA"),
  "CHI3L1" = c("CHI3L1"),
  "CD14"   = c("CD14"),
  "CD33"   = c("CD33"),
  "ITGAM"  = c("ITGAM"),
  "ARG1"   = c("ARG1"),
  "S100A8" = c("S100A8"),
  "S100A9" = c("S100A9"),
  "STAT3"  = c("STAT3"),
  "FUT4"   = c("FUT4"),
  "CYBB"   = c("CYBB"),
  "NCAM1"  = c("NCAM1"),
  "FCGR3A" = c("FCGR3A"),
  "KLRK1"  = c("KLRK1"),
  "NCR1"   = c("NCR1"),
  "NCR3"   = c("NCR3"),
  "PRF1"   = c("PRF1"),
  "GZMB"   = c("GZMB"),
  "GZMA"   = c("GZMA"),
  "IFNG"   = c("IFNG"),
  "KIR2DL1"= c("KIR2DL1"),
  "KIR3DL1"= c("KIR3DL1"),
  "CD8A"   = c("CD8A"),
  "CD8B"   = c("CD8B"),
  "TBX21"  = c("TBX21"),
  "CXCR3"  = c("CXCR3"),
  "CD4"    = c("CD4"),
  "IL2"    = c("IL2"),
  "STAT1"  = c("STAT1"),
  "RORC"   = c("RORC"),
  "IL17A"  = c("IL17A"),
  "IL17F"  = c("IL17F"),
  "IL23R"  = c("IL23R"),
  "FOXP3"  = c("FOXP3"),
  "IL2RA"  = c("IL2RA","CD25"),
  "CTLA4"  = c("CTLA4"),
  "IKZF2"  = c("IKZF2","HELIOS"),
  "IL7R"   = c("IL7R")
)

name_upper <- toupper(df[["gene-name"]])

# --- Función para graficar un gen (acepta símbolo o sinónimo) ---
plot_gene <- function(gene_input,
                      col_mediana = "#F28E2B",  # naranja
                      col_puntos  = "#6BAED6")  # celeste
{
  target <- toupper(gene_input)

  # Resolver a canónico
  syn2canon <- setNames(rep(names(gene_map), lengths(gene_map)), unlist(gene_map))
  if (target %in% toupper(names(gene_map))) {
    canon <- names(gene_map)[match(target, toupper(names(gene_map)))]
  } else if (target %in% toupper(names(syn2canon))) {
    canon <- syn2canon[[ names(syn2canon)[match(target, toupper(names(syn2canon)))] ]]
  } else {
    stop("Gen no reconocido: ", gene_input)
  }

  # Buscar fila por sinónimos
  idx <- which(name_upper %in% toupper(gene_map[[canon]]))
  if (!length(idx)) stop("No encontré '", canon, "' en la columna 'gene-name'.")
  row_i <- idx[1]

  # Extraer valores
  vals <- as.numeric(as.vector(unlist(df[row_i, tumor_cols])))
  vals <- vals[!is.na(vals)]
  if (!length(vals)) stop("Sin valores de expresión no-NA para ", canon, ".")

  dat <- data.frame(gene = canon, expression = vals)

  # Boxplot (estilo solicitado) y etiquetas pedidas
  g <- ggplot(dat, aes(x = gene, y = expression)) +
    geom_boxplot(width = 0.5,
                 fill = "white", colour = "black",
                 outlier.shape = 21, outlier.size = 2.2, outlier.fill = "white") +
    # mediana resaltada
    stat_summary(fun = median, geom = "crossbar", width = 0.5,
                 colour = col_mediana, linewidth = 1.4) +
    # puntos "x" celestes
    geom_point(position = position_jitter(width = 0.08, height = 0),
               shape = 4, size = 2.2, stroke = 0.9,
               colour = col_puntos, alpha = 0.85) +
    labs(x = NULL,
         y = "FPKM_UQ_UNSTRANDED",
         title = paste0("Expresión de ", gene_input)) +
    theme_minimal(base_size = 18) +
    theme(panel.grid.minor = element_blank(),
          panel.grid.major.x = element_blank(),
          panel.grid.major.y = element_line(colour = "grey85"),
          axis.text.x = element_text(size = 16),
          axis.title.y = element_text(size = 18),
          plot.title  = element_text(size = 22, face = "bold")) +
    scale_y_continuous(expand = expansion(mult = c(0.02, 0.08)))

  return(g)
}
```


# Render en grilla

```{r render_grid, fig.width=12, fig.height=9}

if (!requireNamespace("gridExtra", quietly = TRUE)) install.packages("gridExtra")
library(gridExtra)

render_grid <- function(titulo, genes, ncol = 3) {
  cat(sprintf("\n\n### %s\n\n", titulo))

  old_df         <- if (exists("df")) df else NULL
  old_name_upper <- if (exists("name_upper")) name_upper else NULL
  old_tumor_cols <- if (exists("tumor_cols")) tumor_cols else NULL

  on.exit({
    if (!is.null(old_df))         df <<- old_df
    if (!is.null(old_name_upper)) name_upper <<- old_name_upper
    if (!is.null(old_tumor_cols)) tumor_cols <<- old_tumor_cols
  }, add = TRUE)

  need_reload <- !(exists("df") && exists("tumor_cols") && all(tumor_cols %in% colnames(df)))
  if (need_reload) {
    path_local <- "genes_subset_sin_dup.tsv"
    expr_df <- if (file.exists(path_local)) {
      read.delim(path_local, sep = "\t", check.names = FALSE, stringsAsFactors = FALSE)
    } else {
      read.delim("https://raw.githubusercontent.com/Lamartaav/TESIS/refs/heads/main/genes_subset_sin_dup.tsv",
                 sep = "\t", check.names = FALSE, stringsAsFactors = FALSE)
    }
    meta_cols   <- c("gene-id","gene-name","gene-type")
    sample_cols <- setdiff(colnames(expr_df), meta_cols)
    tumor_cols_new <- sample_cols[grepl("-01A-", sample_cols)]
    if (length(tumor_cols_new) == 0) tumor_cols_new <- sample_cols

    df <<- expr_df
    tumor_cols <<- tumor_cols_new
    name_upper <<- toupper(df[["gene-name"]])
  }

  plots <- lapply(genes, function(g) {
    tryCatch({
      p <- plot_gene(g)
      # achicar títulos y eje Y
      p + theme(
        plot.title  = element_text(size = 14, face = "bold"),
        axis.title.y = element_text(size = 12),
        axis.text.y  = element_text(size = 10)
      )
    }, error = function(e) {
      ggplot() +
        annotate("text", x = 0, y = 0, label = paste("Error con", g, ":", e$message)) +
        theme_void()
    })
  })

  grid.arrange(grobs = plots, ncol = ncol)
}

# Aplicar a cada grupo
render_grid("PARÁMETROS METABÓLICOS", c("SLC2A1", "CA9", "HIF1A", "EPAS1", "LDHA", "SLC16A1", "SLC16A3", "HK2", "PKM", "GPI", "ALDOA", "PGK1", "PGM1", "ENO1", "CD274"), ncol=3)
render_grid("Infiltrado inmune", c("CD80", "CD86", "HLA-DRA", "IL12B", "NOS2", "TNF", "IL1B", "CXCL9", "CXCL10"), ncol=3)
render_grid("Macrófagos M2", c("CD163", "MRC1", "IL10", "TGFB1", "MMP9", "VEGFA", "CHI3L1"), ncol=3)
render_grid("M-MDSC", c("CD14", "CD33", "ITGAM", "IL10", "ARG1", "NOS2", "S100A8", "S100A9", "STAT3"), ncol=3)
render_grid("PMN-MDSC", c("FUT4", "CD33", "S100A8", "S100A9", "ARG1", "CYBB") , ncol=3)
render_grid("celulas NK", c("NCAM1", "FCGR3A", "KLRK1", "NCR1", "NCR3", "PRF1", "GZMB", "GZMA", "IFNG", "KIR2DL1", "KIR3DL1") , ncol=3)
render_grid("Linfocitos T CD8+", c("CD8A", "CD8B", "PRF1", "GZMB", "IFNG", "TBX21", "CXCR3") , ncol=3)
render_grid("Linfocitos T CD4+ Th1", c("CD4", "TBX21", "IFNG", "IL2", "STAT1") , ncol=3)
render_grid("Linfocitos T CD4+ Th17", c("CD4", "RORC", "IL17A", "IL17F", "IL23R")  , ncol=3)
render_grid(" T reguladores (Tregs)", c("FOXP3", "IL2RA", "CTLA4", "IKZF2", "TGFB1", "IL10",  "IL7R"), ncol=3)
```


# Grafico de Keplen-Meier
```{r km_desde_url_fix, message=FALSE, warning=FALSE, fig.width=7, fig.height=5}
# Paquetes
pkgs <- c("readr","dplyr","stringr","survival","survminer","ggplot2","forcats")
to_install <- pkgs[!sapply(pkgs, requireNamespace, quietly = TRUE)]
if (length(to_install)) install.packages(to_install)
invisible(lapply(pkgs, library, character.only = TRUE))

# URL provista + fallback
url1 <- "https://raw.githubusercontent.com/Lamartaav/TESIS/refs/heads/main/pacientesIV.tsv"
url2 <- sub("/refs/heads/", "/", url1)

# Leer datos
df <- tryCatch(
  readr::read_tsv(url1, show_col_types = FALSE),
  error = function(e) {
    message("No se pudo leer desde url1; probando url alternativa...")
    readr::read_tsv(url2, show_col_types = FALSE)
  }
)

# --- Localizar columnas clave sin renombrar ---
col_status <- names(df)[grepl("vital_status", names(df), ignore.case = TRUE)][1]
col_dtd    <- names(df)[grepl("days_to_death", names(df),  ignore.case = TRUE)][1]
col_lfu    <- names(df)[grepl("days_to_last_follow", names(df), ignore.case = TRUE)][1]

if (is.na(col_dtd) || is.na(col_lfu)) {
  stop("Faltan columnas de tiempo: se esperaban 'demographic.days_to_death' y 'diagnoses.days_to_last_follow_up'.")
}

# Coerción numérica
days_to_death <- suppressWarnings(as.numeric(df[[col_dtd]]))
days_to_lfu   <- suppressWarnings(as.numeric(df[[col_lfu]]))

# Evento (1=Dead, 0=Alive)
event <- if (!is.na(col_status)) {
  vs <- tolower(as.character(df[[col_status]]))
  ifelse(vs == "dead", 1L, 0L)
} else {
  ifelse(!is.na(days_to_death) & days_to_death >= 0, 1L, 0L)
}

# Tiempo (días)
time_days <- ifelse(event == 1 & !is.na(days_to_death), days_to_death, days_to_lfu)

# Filtrar válidos
keep  <- !is.na(time_days) & time_days >= 0
km_df <- dplyr::tibble(time_days = time_days[keep], event = event[keep])

# --- Gráfico de barras de estado vital (si existe) ---
if (!is.na(col_status)) {
  df$vital_status_std <- forcats::fct_relevel(
    stringr::str_to_title(as.character(df[[col_status]])), "Dead", "Alive"
  )
  tabla_estado <- df |>
    dplyr::count(vital_status_std, name = "n") |>
    dplyr::mutate(pct = n / sum(n))
  print(tabla_estado)

  p_barras <- ggplot(tabla_estado, aes(x = vital_status_std, y = n)) +
    geom_col() +
    geom_text(aes(label = n), vjust = -0.35, size = 4) +
    scale_y_continuous(expand = expansion(mult = c(0, 0.10))) +
    labs(title = "Estado vital de los pacientes", x = NULL, y = "Cantidad") +
    theme_minimal(base_size = 12)
print(p_barras)
}

# --- Kaplan–Meier ---
if (nrow(km_df) < 2 || sum(km_df$event, na.rm = TRUE) == 0) {
  stop("No hay suficientes datos/eventos para estimar una curva de Kaplan–Meier.")
}

fit <- survival::survfit(Surv(time_days, event) ~ 1, data = km_df)

# Mediana de sobrevida
med <- tryCatch(survminer::surv_median(fit)$median, error = function(e) NA_real_)
if (!is.na(med)) message(sprintf("Mediana de sobrevida: %.1f días", med))

# Gráfico KM
p_km <- survminer::ggsurvplot(
  fit, data = km_df,
  conf.int = TRUE,
  risk.table = TRUE,
  risk.table.height = 0.25,
  xlab = "Días de seguimiento",
  ylab = "Probabilidad de supervivencia",
  title = "Curva de Kaplan–Meier (sobrevida global)",
  censor = TRUE
)
print(p_km)
```






