---
title: "Kapplan Meier LUSC"
author: "MV - VS"
date: "2025-10-03"
output: html_document
---

El método del cutpoint óptimo busca el valor de expresión que maximiza la diferencia en supervivencia entre los dos grupos. 
1. Se ordenan los pacientes por valor de CA9 (de más bajo a más alto).
2. Se prueban todos los posibles cortes (valores de CA9 donde podría dividirse Low vs High). Ejemplo: si      hay 100 pacientes, se prueban ~98 cortes (del paciente 2 al 99).
3. Para cada corte se hace un test log-rank de supervivencia (Low vs High).
4. Se guarda el corte que da la estadística más significativa (máxima separación entre curvas).


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE)

library(survival)
library(survminer)
library(dplyr)
library(tidyverse)
library(ggrepel)
library(scales)
library(ggplot2)
library(plotly)

library(dplyr)
library(tidyr)
library(ggsignif)
library(rstatix)
```

``` {r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
need <- function(pkgs){
  miss <- pkgs[!sapply(pkgs, requireNamespace, quietly = TRUE)]
  if(length(miss)) install.packages(miss)
  invisible(lapply(pkgs, library, character.only = TRUE))
}
need(c("tidyverse","readr","survival","survminer","broom"))



```

``` {r, include=FALSE}
url_clin <- "https://raw.githubusercontent.com/Lamartaav/TESIS/refs/heads/main/clinical_unido_KM.tsv"
url_expr <- "https://raw.githubusercontent.com/Lamartaav/TESIS/refs/heads/main/tejido_tumoral_LUSC.tsv"

clinical <- readr::read_tsv(url_clin, na = c("", "NA", "--"))
expr     <- readr::read_tsv(url_expr, na = c("", "NA", "--"))

# Chequeo mínimo
dplyr::glimpse(clinical)
dplyr::glimpse(expr)

```

``` {r, echo=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# Nos quedamos con columnas clave + CA9
stopifnot("CA9" %in% names(expr))

expr_ca9 <- expr %>%
  dplyr::select(submitter_id, Project, CA9) %>%
  dplyr::mutate(CA9 = suppressWarnings(as.numeric(CA9))) %>%
  dplyr::filter(!is.na(submitter_id), !is.na(CA9))

# Cuartiles sobre CA9
qs <- quantile(expr_ca9$CA9, probs = c(0.25, 0.75), na.rm = TRUE)

expr_ca9 <- expr_ca9 %>%
  dplyr::mutate(
    CAIX_group = dplyr::case_when(
      CA9 <= qs[[1]] ~ "Low",
      CA9 >= qs[[2]] ~ "High",
      TRUE ~ NA_character_
    )
  ) %>%
  dplyr::filter(!is.na(CAIX_group)) %>%   # solo bottom/top quartile
  dplyr::mutate(CAIX_group = factor(CAIX_group, levels = c("Low","High")))


```

``` {r, echo=FALSE, message=FALSE, warning=FALSE, include=FALSE}

# Quedarnos con CA9 numérico y SIN filtrar por cuartiles (todos los pacientes)
stopifnot("CA9" %in% names(expr))

expr_ca9 <- expr %>%
  dplyr::select(submitter_id, Project, CA9) %>%
  dplyr::mutate(CA9 = suppressWarnings(as.numeric(CA9))) %>%
  dplyr::filter(!is.na(submitter_id), !is.na(CA9))


```

``` {r, echo=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# Emparejar por submitter_id (expresión) con cases.submitter_id (clínica)
dat_lusc <- expr_ca9 %>%
  dplyr::inner_join(
    clinical %>% 
      dplyr::select(
        cases.submitter_id,
        demographic.vital_status,
        diagnoses.days_to_last_follow_up,
        diagnoses.days_to_diagnosis,
        project.project_id
      ),
    by = c("submitter_id" = "cases.submitter_id")
  ) %>%
  # Filtrar proyecto lusc explícito en clínica
  dplyr::filter(project.project_id == "TCGA-LUSC")

# Limpiar y calcular tiempo (meses) desde diagnóstico hasta último follow-up o muerte
dat_lusc <- dat_lusc %>%
  dplyr::mutate(
    d_dx    = suppressWarnings(as.numeric(diagnoses.days_to_diagnosis)),
    d_last  = suppressWarnings(as.numeric(diagnoses.days_to_last_follow_up)),
    time_d  = d_last - d_dx,
    # descartar tiempos negativos o faltantes
    time_d  = ifelse(is.na(time_d) | time_d < 0, NA, time_d),
    time_mo = time_d / 30.44,
    status  = ifelse(tolower(demographic.vital_status) == "dead", 1, 0)
  ) %>%
  dplyr::filter(!is.na(time_mo), !is.na(status))
  
# Tamaños por grupo
table(dat_lusc$CAIX_group)

```

``` {r, echo=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# Aseguramos que CA9 es numérico
dat_lusc$CA9 <- suppressWarnings(as.numeric(dat_lusc$CA9))

# 1) Grupos por MEDIANA
med <- median(dat_lusc$CA9, na.rm = TRUE)
dat_med <- dat_lusc %>%
  dplyr::mutate(CAIX_group = ifelse(CA9 <= med, "Low", "High")) %>%
  dplyr::mutate(CAIX_group = factor(CAIX_group, levels = c("Low","High")))

# Modelo KM
fit_med <- survival::survfit(Surv(time_mo, status) ~ CAIX_group, data = dat_med)

# Cox HR (High vs Low)
cox_med <- survival::coxph(Surv(time_mo, status) ~ CAIX_group, data = dat_med)
hr_med  <- broom::tidy(cox_med, exponentiate = TRUE, conf.int = TRUE) |>
  dplyr::filter(term == "CAIX_groupHigh") |>
  dplyr::mutate(lbl = paste0(
    "Cox HR (High vs Low) = ", sprintf("%.2f", estimate),
    " (95% CI ", sprintf("%.2f", conf.low), "–", sprintf("%.2f", conf.high), ")"
  )) |>
  dplyr::pull(lbl)

# Plot
p_med <- survminer::ggsurvplot(
  fit_med, data = dat_med,
  risk.table = TRUE, pval = TRUE, conf.int = FALSE,
  legend.title = "CAIX (CA9)", legend.labs = c("Low","High"),
  xlab = "Time (months)", ylab = "Overall survival probability (TCGA-LUSC)",
  break.time.by = 25, risk.table.height = 0.25,
  ggtheme = ggplot2::theme_bw(base_size = 12),
  title = "Median split (Low ≤ median ≤ High)"
)

p_med$plot <- p_med$plot +
  ggplot2::annotate("text", x = Inf, y = 1.02, label = hr_med,
                    hjust = 1.02, vjust = 1, size = 4.2)

p_med

```

``` {r, echo=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# --- Cutpoint óptimo, versión robusta ---
cut <- survminer::surv_cutpoint(
  data  = dat_lusc,
  time  = "time_mo",
  event = "status",
  variables = "CA9",
  minprop = 0.10
)

# Convierte el resultado categorizado a data.frame "puro"
dat_opt <- survminer::surv_categorize(cut)
dat_opt <- as.data.frame(dat_opt)

# Renombrar columnas de tiempo/evento si hace falta
if ("time"  %in% names(dat_opt))  names(dat_opt)[names(dat_opt)=="time"]  <- "time_mo"
if ("event" %in% names(dat_opt))  names(dat_opt)[names(dat_opt)=="event"] <- "status"

# Detectar automáticamente la columna del gen (la que no es time_mo/status)
gen_col <- setdiff(names(dat_opt), c("time_mo","status"))
stopifnot(length(gen_col) == 1)   # debe haber solo una (CA9 categorizado)

# Renombrar a CAIX_group y setear niveles Low/High
names(dat_opt)[names(dat_opt)==gen_col] <- "CAIX_group"
dat_opt$CAIX_group <- factor(dat_opt$CAIX_group,
                             levels = c("low","high"),
                             labels = c("Low","High"))

# Chequeo
table(dat_opt$CAIX_group)

# KM y Cox
fit_opt <- survival::survfit(Surv(time_mo, status) ~ CAIX_group, data = dat_opt)
cox_opt <- survival::coxph(Surv(time_mo, status) ~ CAIX_group, data = dat_opt)
hr_opt  <- broom::tidy(cox_opt, exponentiate = TRUE, conf.int = TRUE) |>
  dplyr::filter(term == "CAIX_groupHigh") |>
  dplyr::mutate(lbl = paste0(
    "Cox HR (High vs Low) = ", sprintf("%.2f", estimate),
    " (95% CI ", sprintf("%.2f", conf.low), "–", sprintf("%.2f", conf.high), ")"
  )) |>
  dplyr::pull(lbl)

# Valor del corte usado
cp_val <- cut$cutpoint$cutpoint[ cut$cutpoint$variable == "CA9" ]
cp_lab <- paste0("Cutpoint óptimo CA9 = ", signif(cp_val, 4))

# Plot
p_opt <- survminer::ggsurvplot(
  fit_opt, data = dat_opt,
  risk.table = TRUE, pval = TRUE, conf.int = FALSE,
  legend.title = "CAIX (CA9)", legend.labs = c("Low","High"),
  xlab = "Time (months)", ylab = "Overall survival probability (TCGA-LUSC)",
  break.time.by = 25, risk.table.height = 0.25,
  ggtheme = ggplot2::theme_bw(base_size = 12),
  title = "Optimal cutpoint (maximally selected rank statistics)"
)

p_opt$plot <- p_opt$plot +
  ggplot2::annotate("text", x = Inf, y = 1.02, label = hr_opt,
                    hjust = 1.02, vjust = 1, size = 4.2) +
  ggplot2::annotate("text", x = -Inf, y = 1.02, label = cp_lab,
                    hjust = -0.02, vjust = 1, size = 3.8)

p_opt

```

``` {r, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE, fig.width=7, fig.height=7, fig.align='center'} 
# Figura 2: Optimal cutpoint
print(p_opt)
# Figura 1: Median split
print(p_med)
```