---

title: "Correlación de Pearson — Panel vs TODOS los genes (Solo tumor TCGA 01–09)"
output: html_document

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE)

library(survival)
library(survminer)
library(dplyr)
library(tidyverse)
library(ggrepel)
library(scales)
library(ggplot2)
library(plotly)

library(dplyr)
library(tidyr)
library(ggsignif)
library(rstatix)
```


```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE)

need <- function(pkgs){
  miss <- pkgs[!sapply(pkgs, requireNamespace, quietly = TRUE)]
  if(length(miss)) install.packages(miss)
  invisible(lapply(pkgs, library, character.only = TRUE))
}
need(c("tidyverse","GGally","ggplot2"))

# TSV desde GitHub
url_tsv <- "https://raw.githubusercontent.com/Lamartaav/TESIS/refs/heads/main/genes_subset_sin_dup.tsv"
tabla <- read.delim(url_tsv, check.names = FALSE, stringsAsFactors = FALSE)

# Primeras 3 columnas: gene-id, gene-name, gene-type
meta_cols <- 1:3
patient_cols  <- (max(meta_cols)+1):ncol(tabla)
patient_names <- colnames(tabla)[patient_cols]

# Extraer YY (dos dígitos) del 4º término del código TCGA
two_digits_of_4th <- function(x){
  parts <- strsplit(x, "-", fixed = TRUE)
  sapply(parts, function(p){
    if (length(p) >= 4) sub("^([0-9]{2}).*$", "\\1", p[[4]]) else NA_character_
  })
}
yy     <- two_digits_of_4th(patient_names)
yy_num <- suppressWarnings(as.integer(yy))

# Filtro: SOLO tumor (01–09)
tumor_mask <- !is.na(yy_num) & yy_num >= 1 & yy_num <= 9
tumor_patient_names <- patient_names[tumor_mask]
tumor_patient_cols  <- match(tumor_patient_names, colnames(tabla))
stopifnot(length(tumor_patient_cols) > 0)

# Matriz de expresión: filas = genes, columnas = pacientes (solo tumor)
expr_gxp <- tabla[, tumor_patient_cols, drop = FALSE]
expr_gxp[] <- lapply(expr_gxp, function(x) suppressWarnings(as.numeric(x)))

# Nombres de fila = gene-name (columna 2)
rownames(expr_gxp) <- make.unique(as.character(tabla[[2]]))

# Transformación (recomendado)
APLICAR_LOG2 <- TRUE
if (APLICAR_LOG2) expr_gxp <- log2(expr_gxp + 1)

# Transponer: filas = pacientes, columnas = genes
X <- as.data.frame(t(as.matrix(expr_gxp)))

# Quitar genes sin varianza (necesario para correlación)
var_gen <- apply(X, 2, stats::var, na.rm = TRUE)
X <- X[, var_gen > 0 & !is.na(var_gen), drop = FALSE]

cat("Pacientes tumor usados:", nrow(X), " | Genes disponibles:", ncol(X), "\n")

```





```{r, echo=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# Panel 1 (columnas)
panel_1 <- c("SLC2A1","CA9","HIF1A","EPAS1","LDHA","SLC16A1","SLC16A3")
# Panel 2 (columnas)
panel_2 <- c("HK2","PKM2","GPI","ALDOA","PGK1","PGM1","ENO1","CD24")

# Mantener solo los genes presentes
presentes <- function(v) { intersect(v, colnames(X)) }
faltan    <- function(v) { setdiff(v, colnames(X)) }
if(length(faltan(panel_1))) message("Panel 1 omitidos: ", paste(faltan(panel_1), collapse=", "))
if(length(faltan(panel_2))) message("Panel 2 omitidos: ", paste(faltan(panel_2), collapse=", "))
panel_1 <- presentes(panel_1)
panel_2 <- presentes(panel_2)

# Filas = TODOS los genes (orden alfabético), en bloques de 10
todos_y <- sort(colnames(X), method = "radix")
chunks_de_10 <- split(todos_y, ceiling(seq_along(todos_y)/10))
# ---- Panel personalizado: puntos + recta lm + r de Pearson con estrellitas ----
panel_scatter_r <- function(data, mapping, ...){
  # Nombres de columnas (compatibles con versiones viejas de ggplot2)
  xname <- rlang::as_name(mapping$x)
  yname <- rlang::as_name(mapping$y)
  x <- data[[xname]]
  y <- data[[yname]]

  # r y p-valor (Pearson)
  r <- suppressWarnings(cor(x, y, use = "pairwise.complete.obs", method = "pearson"))
  p <- tryCatch(
    suppressWarnings(cor.test(x, y, method = "pearson")$p.value),
    error = function(e) NA_real_
  )

  # Estrellitas por p-valor
  stars <- if (is.na(p)) "" else if (p < 0.001) "***" else if (p < 0.01) "**" else if (p < 0.05) "*" else ""

  ggplot2::ggplot(data = data, mapping = mapping) +
    ggplot2::geom_point(alpha = 0.45, size = 0.6) +
    ggplot2::geom_smooth(method = "lm", se = FALSE, linewidth = 0.35) +
    ggplot2::annotate("text",
      x = Inf, y = Inf,
      label = sprintf("r = %.2f%s", r, stars),
      hjust = 1.1, vjust = 1.3, size = 3.2
    )
}

# Función para graficar un bloque (panel de columnas vs 10 genes de filas)
plot_bloque <- function(cols_panel, filas_10, titulo){
  # tamaños para que quepa
  fw <- max(14, 1.6 * length(cols_panel) + 4)
  fh <- max(12, 1.2 * length(filas_10) + 6)
  knitr::opts_current$set(fig.width = fw, fig.height = fh)

  g <- GGally::ggduo(
    data = X,
    columnsX = cols_panel,           # columnas = tu panel
    columnsY = filas_10,             # filas = 10 genes del chunk
    types = list(continuous = panel_scatter_r),  # nuestro panel en todas las celdas
    showStrips = TRUE,
    title = titulo
  ) +
    theme_bw(base_size = 9) +
    theme(
      strip.background = element_rect(fill = "grey95"),
      panel.grid.minor = element_blank(),
      plot.title = element_text(hjust = 0.5)
    )
  print(g)
}

```

Regla de estrellitas: * p<0.05, ** p<0.01, *** p<0.001.

```{r, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE, fig.width=10, fig.height=10, fig.align='center'} 
if(length(panel_1) > 0){
  for(i in seq_along(chunks_de_10)){
    filas <- chunks_de_10[[i]]
    plot_bloque(
      cols_panel = panel_1,
      filas_10   = filas,
      titulo     = sprintf("Correlación (Pearson) — Panel 1 (columnas) vs Bloque %d/%d de genes (filas) | Tumor TCGA 01–09",
                           i, length(chunks_de_10))
    )
  }
}

```



```{r, echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE, fig.width=10, fig.height=10, fig.align='center'}
if(length(panel_2) > 0){
  for(i in seq_along(chunks_de_10)){
    filas <- chunks_de_10[[i]]
    plot_bloque(
      cols_panel = panel_2,
      filas_10   = filas,
      titulo     = sprintf("Correlación (Pearson) — Panel 2 (columnas) vs Bloque %d/%d de genes (filas) | Tumor TCGA 01–09",
                           i, length(chunks_de_10))
    )
  }
}

```
```{r, echo=FALSE, message=FALSE, warning=FALSE, include=TRUE}
need <- function(pkgs){
  miss <- pkgs[!sapply(pkgs, requireNamespace, quietly = TRUE)]
  if(length(miss)) install.packages(miss)
  invisible(lapply(pkgs, library, character.only = TRUE))
}
need(c("dplyr","purrr","knitr","kableExtra"))

# ---------- utilidades ----------
# correlación de un vector con todas las columnas de una matriz
corr_with_all <- function(v, M){
  n <- colSums(!is.na(M) & !is.na(v))
  r <- suppressWarnings(cor(M, v, use = "pairwise.complete.obs", method = "pearson"))
  p <- rep(NA_real_, length(r))
  ok <- which(n >= 3 & is.finite(r) & abs(r) < 1)
  tval <- r[ok] * sqrt((n[ok]-2) / pmax(1e-12, 1 - r[ok]^2))
  p[ok] <- 2 * pt(-abs(tval), df = n[ok]-2)
  list(r=r, p=p, n=n)
}
stars_from_p <- function(p){
  ifelse(is.na(p), "",
  ifelse(p < 0.001, "***",
  ifelse(p < 0.01,  "**",
  ifelse(p < 0.05,  "*",  ""))))
}

# Matriz de expresión como matrix (por si X es data.frame)
M <- as.matrix(X)

# Umbrales (cambiá acá si querés otra regla)
r_thr <- 0.20
p_thr <- 0.05   # Si realmente querés p>0.05 cambiá a 'p_thr <- 0.05' y usa 'p > p_thr' en el filtro de abajo.

# Paneles presentes en la matriz
paneles <- unique(c(panel_1, panel_2))
paneles <- intersect(paneles, colnames(M))
if(length(paneles) == 0){
  stop("Ningún gen de panel_1/panel_2 está en la matriz X.")
}

# --------- generar tablas ----------
for(g in paneles){
  res <- corr_with_all(M[, g], M)

  # armo tibble y saco la autocorrelación con el mismo gen 'g'
  tb <- tibble::tibble(
    gen_fila = colnames(M),
    r        = as.numeric(res$r),
    p        = as.numeric(res$p)
  ) %>%
    dplyr::filter(gen_fila != g) %>%
    # FILTRO: |r| >= 0.20 y p < 0.05
    dplyr::filter((r >=  r_thr | r <= -r_thr) & p < p_thr) %>%
    dplyr::mutate(Significancia = stars_from_p(p)) %>%
    dplyr::arrange(dplyr::desc(abs(r))) %>%
    dplyr::mutate(r = round(r, 2)) %>%
    dplyr::select(`Gen (fila)` = gen_fila, r, Significancia)

  # Título de la tabla
  subt <- sprintf("Gen (panel) %s — |r| ≥ %.2f y p < %.2f", g, r_thr, p_thr)

  if(nrow(tb) == 0){
    cat("\n\n###", g, "\n\n*No hay genes que cumplan el filtro.*\n\n")
  } else {
    # imprimir tabla bonita
    tb %>%
      knitr::kable(align = c("l","c","c"), caption = subt) %>%
      kableExtra::kable_styling(full_width = FALSE, bootstrap_options = c("striped","hover")) %>%
      print()

    # Listas pedidas
    pos <- tb %>% dplyr::filter(r > 0) %>% dplyr::pull(`Gen (fila)`)
    neg <- tb %>% dplyr::filter(r < 0) %>% dplyr::pull(`Gen (fila)`)

    cat("\nPara el gen", g, "los genes que se correlacionan positivamente son:",
        if(length(pos)) paste(pos, collapse = ", ") else "ninguno", "\n\n")
    cat("Para el gen", g, "los genes que se correlacionan negativamente son:",
        if(length(neg)) paste(neg, collapse = ", ") else "ninguno", "\n\n")
  }
}

```

